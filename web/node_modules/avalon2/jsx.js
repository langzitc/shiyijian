 var avalon = {
     log: function(){},
     error: function(){},
     warn: function(){}
 }
 var stringNum = 0
 var stringPool = {
    map: {}
}
 var rfill = /\?\?\d+/g
 function dig(a) {
    var key = '??' + stringNum++
    stringPool.map[key] = a
    return key + ' '
}
 function fill(a) {
    var val = stringPool.map[a]
    return val
}
 function clearString(str) {
    var array = readString(str)
    for (var i = 0, n = array.length; i < n; i++) {
        str = str.replace(array[i], dig)
    }
    return str
}

function readString(str) {
    var end, s = 0
    var ret = []
    for (var i = 0, n = str.length; i < n; i++) {
        var c = str.charAt(i)
        if (!end) {
            if (c === "'") {
                end = "'"
                s = i
            } else if (c === '"') {
                end = '"'
                s = i
            }
        } else {
            if (c === end) {
                ret.push(str.slice(s, i + 1))
                end = false
            }
        }
    }
    return ret
}

 var orphanTag = {
    script: 2,
    style: 2,
    textarea: 2,
    xmp: 2,
    noscript: 2,
    template: 2,
    option: 0
}

 var svgTag = {

}


 var voidTag = {
    area: 1,
    base: 1,
    basefont: 1,
    bgsound: 1,
    br: 1,
    col: 1,
    command: 1,
    embed: 1,
    frame: 1,
    hr: 1,
    img: 1,
    input: 1,
    keygen: 1,
    link: 1,
    meta: 1,
    param: 1,
    source: 1,
    track: 1,
    wbr: 1
}

/* 
 *  此模块只用于文本转虚拟DOM, 
 *  因为在真实浏览器会对我们的HTML做更多处理,
 *  如, 添加额外属性, 改变结构
 *  此模块就是用于模拟这些行为
 */
 function makeOrphan(node, nodeName, innerHTML) {
    switch (nodeName) {
        case 'style':
        case 'script':
        case 'noscript':
        case 'template':
        case 'xmp':
            node.children = [{
                nodeName: '#text',
                nodeValue: innerHTML
            }]
            break
        case 'textarea':
            var props = node.props
            props.type = nodeName
            props.value = innerHTML
            node.children = [{
                nodeName: '#text',
                nodeValue: innerHTML
            }]
            break
        case 'option':
            node.children = [{
                nodeName: '#text',
                nodeValue: trimHTML(innerHTML)
            }]
            break
    }

}

//专门用于处理option标签里面的标签
var rtrimHTML = /<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi

function trimHTML(v) {
    return String(v).replace(rtrimHTML, '').trim()
}

function nomalString(str) {
    return str.replace(rfill, fill)
}
//https://github.com/rviscomi/trunk8/blob/master/trunk8.js

var ropenTag = /^<([-A-Za-z0-9_]+)\s*([^>]*?)(\/?)>/
var rendTag = /^<\/([^>]+)>/
var rtagStart = /[\!\/a-z]/i //闭标签的第一个字符,开标签的第一个英文,注释节点的!
var rlineSp = /\\n\s*/g
var rattrs = /([^=\s]+)(?:\s*=\s*(\S+))?/

var rcontent = /\S/ //判定里面有没有内容
 function StringConvertor(str) {
   

    vdomAst.init(str)
    var ret = vdomAst.gen()
    return ret
}


function AST() {}
AST.prototype = {
    init(str) {
        this.ret = []
        var stack = []
        stack.last = function() {
            return stack[stack.length - 1]
        }
        this.stack = stack
        this.str = str
    },
    gen() {
        var breakIndex = 999999
        do {
            this.tryGenText()
            this.tryGenComment()
            this.tryGenOpenTag()
            this.tryGenCloseTag()
            var node = this.node
            this.node = 0
            if (!node || --breakIndex === 0) {
                break
            }
            if (node.end) {
                if (node.nodeName === 'table') {
                    makeTbody(node.children)
                }
                delete node.end
            }
        } while (this.str.length);
        return this.ret
    },
    fixPos: function(str, i) {
        var tryCount = str.length - i
        while (tryCount--) {
            if (!rtagStart.test(str.charAt(i + 1))) {
                i = str.indexOf('<', i + 1)
            } else {
                break
            }
        }
        if (tryCount === 0) {
            i = str.length
        }
        return i
    },
    tryGenText() {
        var str = this.str
        if (str.charAt(0) !== '<') { //处理文本节点
            var i = str.indexOf('<')
            if (i === -1) {
                i = str.length
            } else if (!rtagStart.test(str.charAt(i + 1))) {
                //处理`内容2 {{ (idx1 < < <  1 ? 'red' : 'blue' ) + a }} ` 的情况 
                i = this.fixPos(str, i)
            }
            var nodeValue = str.slice(0, i).replace(rfill, fill)
            this.str = str.slice(i)
            this.node = {
                nodeName: '#text',
                nodeValue: nodeValue
            }
            if (rcontent.test(nodeValue)) {
                this.tryGenChildren() //不收集空白节点
            }
        }
    },
    tryGenComment() {
        if (!this.node) {
            var str = this.str
            var i = str.indexOf('<!--') //处理注释节点
                /* istanbul ignore if*/
            if (i === 0) {
                var l = str.indexOf('-->')
                if (l === -1) {
                    avalon.error('注释节点没有闭合' + str)
                }
                var nodeValue = str.slice(4, l).replace(rfill, fill)
                this.str = str.slice(l + 3)
                this.node = {
                    nodeName: '#comment',
                    nodeValue: nodeValue
                }
                this.tryGenChildren()
            }
        }
    },
    tryGenOpenTag() {
        if (!this.node) {
            var str = this.str
            var match = str.match(ropenTag) //处理元素节点开始部分
            if (match) {
                var type = match[1]
                var props = {}
//                if (/^[A-Z]/.test(type) && avalon.components[type]) {
//                    props.is = type
//                }
                type = type.toLowerCase()
                var isVoidTag = voidTag[type] || match[3] === '\/'
                var node = this.node = {
                    nodeName: type,
                    props: {},
                    children: [],
                    vtype: isVoidTag ? 1 : (orphanTag[type] || 0)
                }
                var attrs = match[2]
                if (attrs) {
                    this.genProps(attrs, node.props)
                }
                this.tryGenChildren()
                str = str.slice(match[0].length)
                if (isVoidTag) {
                    node.end = true
                } else {
                    this.stack.push(node)
                    if (type in orphanTag) {
                        var index = str.indexOf('</' + nodeName + '>')
                        var innerHTML = str.slice(0, index).trim()
                        str = str.slice(index)
                        makeOrphan(node, nodeName, nomalString(innerHTML))
                    }
                }
                this.str = str
            }
        }
    },
    tryGenCloseTag() {
        if (!this.node) {
            var str = this.str
            var match = str.match(rendTag) //处理元素节点结束部分
            if (match) {
                var nodeName = match[1].toLowerCase()
                var last = this.stack.last()
                    /* istanbul ignore if*/
                if (!last) {
                    avalon.error(match[0] + '前面缺少<' + nodeName + '>')
                        /* istanbul ignore else*/
                } else if (last.nodeName !== nodeName) {
                    var errMsg = last.nodeName + '没有闭合,请注意属性的引号'
                    avalon.warn(errMsg)
                    avalon.error(errMsg)
                }
                
                var node = this.stack.pop()
                this.tryGenLogic(node)
                console.log(node,'====')
                node.end = true
                this.node = node
                this.str = str.slice(match[0].length)
            }
        }
    },
    tryGenLogic(node){
       var c = node.children, left, step = 0
       for(var i = 0, n; n = c[i++];){
           if(node.nodeName === '#text'){
               var s = node.nodeValue
               if(!left){
                  var index = s.indexOf('{')
                  if(indexOf !== -1){
                      left = 1
                      step += 1
                  }
               }else{
                   var index = s.indexOf('{')
                   if(index > -1){
                       step += 1
                   }else{
                       index = s.indexOf('}')
                       if(indexOf > -1){
                           if(step === 1){
                               step = 0
                               left = 0
                               
                           }
                       }
                   }
               }
           }
       }
    },
    tryGenChildren() {
        var node = this.node
        var p = this.stack.last()
        if (p) {
           
            p.children.push(node)
        } else {
            this.ret.push(node)
        }
    },
    genProps(attrs, props) {

        while (attrs) {
            var arr = rattrs.exec(attrs)

            if (arr) {
                var name = arr[1]
                var value = arr[2] || ''
                attrs = attrs.replace(arr[0], '')
                if (value) {
                    //https://github.com/RubyLouvre/avalon/issues/1844
                    if (value.indexOf('??') === 0) {
                        value = nomalString(value).
                        replace(rlineSp, '').

                        slice(1, -1)

                    }
                }
                if (!(name in props)) {
                    props[name] = value
                }
            } else {
                break
            }
        }
    }
}

var vdomAst = new AST()