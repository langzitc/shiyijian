/* 
 * 通过绑定事件同步vmodel
 * 总共有三种方式同步视图
 * 1. 各种事件 input, change, click, propertychange, keydown...
 * 2. value属性重写
 * 3. 定时器轮询
 */

import { avalon, getShortID as markID, window, document, msie, modern } from '../../seed/core'
import { updateModel } from './updateDataHandle'


export function updateDataEvents(dom, data) {
    var events = {}
        //添加需要监听的事件
    switch (data.dtype) {
        case 'radio':
        case 'checkbox':
            events.click = updateModel
            break
        case 'select':
            events.change = updateModel
            break
        case 'contenteditable':
            /* istanbul ignore if */
            if (data.isChanged) {
                events.blur = updateModel
                    /* istanbul ignore else */
            } else {
                /* istanbul ignore if*/

                if (avalon.modern) {
                    if (window.webkitURL) {
                        // http://code.metager.de/source/xref/WebKit/LayoutTests/fast/events/
                        // https://bugs.webkit.org/show_bug.cgi?id=110742
                        events.webkitEditableContentChanged = updateModel
                    } else if (window.MutationEvent) {
                        events.DOMCharacterDataModified = updateModel
                    }
                    events.input = updateModel
                        /* istanbul ignore else */
                } else {
                    events.keydown = updateModelKeyDown
                    events.paste = updateModelDelay
                    events.cut = updateModelDelay
                    events.focus = closeComposition
                    events.blur = openComposition
                }

            }
            break
        case 'input':
            /* istanbul ignore if */
            if (data.isChanged) {
                events.change = updateModel
                    /* istanbul ignore else */
            } else {
                //http://www.cnblogs.com/rubylouvre/archive/2013/02/17/2914604.html
                //http://www.matts411.com/post/internet-explorer-9-oninput/
                if (msie < 10) {
                    //IE6-8的propertychange有问题,第一次用JS修改值时不会触发,而且你是全部清空value也不会触发
                    //IE9的propertychange不支持自动完成,退格,删除,复制,贴粘,剪切或点击右边的小X的清空操作
                    events.propertychange = updateModelHack
                    events.paste = updateModelDelay
                    events.cut = updateModelDelay
                        //IE9在第一次删除字符时不会触发oninput
                    events.keyup = updateModelKeyDown
                } else {
                    events.input = updateModel
                    events.compositionstart = openComposition
                        //微软拼音输入法的问题需要在compositionend事件中处理
                    events.compositionend = closeComposition
                        //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray
                        //处理低版本的标准浏览器,通过Int8Array进行区分
                    if (!/\[native code\]/.test(window.Int8Array)) {
                        events.keydown = updateModelKeyDown //safari < 5 opera < 11
                        events.paste = updateModelDelay //safari < 5
                        events.cut = updateModelDelay //safari < 5 
                        if (window.netscape) {
                            // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete
                            events.DOMAutoComplete = updateModel
                        }
                    }
                }
            }
            break
    }

    if (/password|text/.test(dom.type) || dom.contentEditable) {
        events.focus = openCaret //判定是否使用光标修正功能 
        events.blur = closeCaret
        data.getCaret = getCaret
        data.setCaret = setCaret
    }

    for (var name in events) {
        avalon.bind(dom, name, events[name])
    }
}


function updateModelHack(e) {
    if (e.propertyName === 'value') {
        updateModel.call(this, e)
    }
}

function updateModelDelay(e) {
    var elem = this
    setTimeout(function() {
        updateModel.call(elem, e)
    }, 0)
}


function openCaret() {
    this.caret = true
}
/* istanbul ignore next */
function closeCaret() {
    this.caret = false
}
/* istanbul ignore next */
function openComposition() {
    this.composing = true
}
/* istanbul ignore next */
function closeComposition(e) {
    this.composing = false
    updateModelDelay.call(this, e)
}
/* istanbul ignore next */
function updateModelKeyDown(e) {
    var key = e.keyCode
        // ignore
        //    command            modifiers                   arrows
    if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
        return
    updateModel.call(this, e)
}

markID(openCaret)
markID(closeCaret)
markID(openComposition)
markID(closeComposition)
markID(updateModel)
markID(updateModelHack)
markID(updateModelDelay)
markID(updateModelKeyDown)

//IE6-8要处理光标时需要异步
var mayBeAsync = function(fn) {
        setTimeout(fn, 0)
    }
    /* istanbul ignore next */
function setCaret(target, cursorPosition) {
    var range
    if (target.createTextRange) {
        mayBeAsync(function() {
            target.focus()
            range = target.createTextRange()
            range.collapse(true)
            range.moveEnd('character', cursorPosition)
            range.moveStart('character', cursorPosition)
            range.select()
        })
    } else {
        if (modern && target.contentEditable) {
            setModernOffsets(target, { start: cursorPosition, end: cursorPosition })
            return
        }
        target.focus()
        if (target.selectionStart !== undefined) {
            target.setSelectionRange(cursorPosition, cursorPosition)
        }
    }
}
/* istanbul ignore next*/
function getCaret(target) {
    var start = 0
    var normalizedValue
    var range
    var textInputRange
    var len
    var endRange

    if (modern && target.contentEditable) {
        var obj = getModernOffsets(target)
        console.log(obj.end, obj.start)
        return obj.start
    }

    if (target.selectionStart + target.selectionEnd > -1) {
        start = target.selectionStart
    } else {
        range = document.selection.createRange()

        if (range && range.parentElement() === target) {
            len = target.value.length
            normalizedValue = target.value.replace(/\r\n/g, '\n')

            textInputRange = target.createTextRange()
            textInputRange.moveToBookmark(range.getBookmark())

            endRange = target.createTextRange()
            endRange.collapse(false)

            if (textInputRange.compareEndPoints('StartToEnd', endRange) > -1) {
                start = len
            } else {
                start = -textInputRange.moveStart('character', -len)
                start += normalizedValue.slice(0, start).split('\n').length - 1
            }
        }
    }

    return start
}

function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
}

function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();

    if (!selection || selection.rangeCount === 0) {
        return null;
    }

    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;

    var currentRange = selection.getRangeAt(0);

    // In Firefox, range.startContainer and range.endContainer can be "anonymous
    // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
    // divs do not seem to expose properties, triggering a "Permission denied
    // error" if any of its properties are accessed. The only seemingly possible
    // way to avoid erroring is to access a property that typically works for
    // non-anonymous divs and catch any error that may otherwise arise. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
    try {
        /* eslint-disable no-unused-expressions */
        currentRange.startContainer.nodeType;
        currentRange.endContainer.nodeType;
        /* eslint-enable no-unused-expressions */
    } catch (e) {
        return null;
    }

    // If the node and offset values are the same, the selection is collapsed.
    // `Selection.isCollapsed` is available natively, but IE sometimes gets
    // this value wrong.
    var isSelectionCollapsed = isCollapsed(
        selection.anchorNode,
        selection.anchorOffset,
        selection.focusNode,
        selection.focusOffset
    );

    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

    var isTempRangeCollapsed = isCollapsed(
        tempRange.startContainer,
        tempRange.startOffset,
        tempRange.endContainer,
        tempRange.endOffset
    );

    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;

    // Detect whether the selection is backward.
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;

    return {
        start: isBackward ? end : start,
        end: isBackward ? start : end,
    };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
        return;
    }

    var selection = window.getSelection();
    var length = node.textContent.length;
    var start = Math.min(offsets.start, length);
    var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

    // IE 11 uses modern selection, but doesn't support the extend method.
    // Flip backward selections, so we can set with a single range.
    if (!selection.extend && start > end) {
        var temp = end;
        end = start;
        start = temp;
    }

    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);

    if (startMarker && endMarker) {
        var range = document.createRange();
        range.setStart(startMarker.node, startMarker.offset);
        selection.removeAllRanges();

        if (start > end) {
            selection.addRange(range);
            selection.extend(endMarker.node, endMarker.offset);
        } else {
            range.setEnd(endMarker.node, endMarker.offset);
            selection.addRange(range);
        }
    }
}

function getLeafNode(node) {
    while (node && node.firstChild) {
        node = node.firstChild;
    }
    return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
    while (node) {
        if (node.nextSibling) {
            return node.nextSibling;
        }
        node = node.parentNode;
    }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;

    while (node) {
        if (node.nodeType === 3) {
            nodeEnd = nodeStart + node.textContent.length;

            if (nodeStart <= offset && nodeEnd >= offset) {
                return {
                    node: node,
                    offset: offset - nodeStart,
                };
            }

            nodeStart = nodeEnd;
        }

        node = getLeafNode(getSiblingNode(node));
    }
}